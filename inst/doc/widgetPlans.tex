\documentclass{article}

\begin{document}

\title{RFC: Widget Plans}
\maketitle


\section*{Some ideas}

Here are some simple ideas for building widgets. While this document
lives in the tkWidgets directory (for now) the plan is not to be
limited by that functionality. Gtk and other things -- Java etc,
seem like reasonable targets.

Let's start with some definitions.

A primitive widget (pwidget) is simply a set of linked interactive
tools.
Some examples:
\begin{itemize}
\item A text string, a type--in box and a button.
\item A set of linked radio buttons
\item A set of linked check boxes
\item A button -- can have an arbitrary R function associated with it.
\end{itemize}

A widget is an ordered collection (list) of pwidgets.
These get rendered in a single dialog box.
The default values are given by the input list and on exit the state
of the different pwidgets is recorded in the list, which is returned.
A widget can have two hooks, these are not rendered. One is a
pre--rendering hook (a function that takes no arguments) and if
present is run before the widget is rendered.
A post--rendering hook which is run when the widget is closed.
The pre--hook is run on entry and the post--hook is registered with 
\verb+on.exit+. This ensures that it is run when the function is
exited regardless of how. It might be nice (but this will take some
time) to allow it to determine how the exit was achieved (is it an end
or a next or an error or ...).

Widgets are rendered by the \verb+renderWidget+ function.
It returns an object of the \verb+widgetClass+. If the exit is normal
(ie via the {\em end} button) then the users changes will be contained
in the return value. For all other forms of exit the input will be
returned. We need to figure out a good mechanism for signalling the
type of exit.
The rendered widget has an \verb+end+ button and a \verb+cancel+
button.

In the not to distant future the pwidgets will be implemented as S4
classes. This will give them more structure. In the first
implementation they will be lists. However, we will attempt to use an
abstract data type implementation that should let us reuse much of the
code when the methods and classes are implemented.

Next we introduce the concept of {\em chained widgets},
\verb+cWidgets+. 
Basically this is simply a list of widgets that will be rendered
sequentially. 
The \verb+cWidgets+ will also have pre and post rendering hooks (these
happen once for the entire process).

The widgets will have the buttons described in each widget in the list
and additionally \verb+previous+, \verb+next+, \verb+end+ and
\verb+cancel+ buttons.
A counter to indicate state is maintained and used for navigation.

We need to decide how to run the pre and post widget hooks when the
different buttons are pushed (does \verb+next+ run the hook or does
any exit from the widget?).

If the user pushes \verb+cancel+ the whole thing exits (again, we need
some decision about what gets returned). Here one might want to return
both the exit status and the list of widgets actually visited.
Duncan M. suggested that we want the exit status but not the list of
widgets visited.

He also proposed a paged control. In this type of widget the different
controls are represented by tabs. They can be selected in any order
and navigated as desired by the user.

Duncan M. also suggested that widgets should know why they are
exiting.

Another suggestion is that there should be platform specific labels.
I think that this could be done by using \verb+options+ and installing
some package specific ones for {\em tkWidgets}.

\section*{Some specifics}

An example of what seems to be easy and useful is the following.
We can have a list of the form
\begin{verbatim}
list(Wtype="Typein", Name="aaa", Value=NULL, Button=fileBrowser)
\end{verbatim}
This would get rendered as a typein box with name \verb+aaa+. The box
would initially be empty since \verb+Value+ was set to \verb+NULL+
(maybe it should be the empty string). There is a button off the end
of the box that is linked to the \verb+fileBrowser+ function.
This button when clicked will evaluate the \verb+fileBrowser+ function
and put its return value into the typein box.

Then when the widget function returns this value is stored in the
\verb+Value+ slot.

Ok, there is a problem here. It seems that we need an additional layer
of abstraction.
The problem: suppose that the Button is linked to \verb+objectBrowser+
and that the user has selected multiple objects. How do we associate
those with the text in the typein box?
It does not appear that we can do that directly.
So an extra layer of abstraction might be enough for most purposes.
There is a \verb+Value+ slot. This value is supplied by the user or 
it is the return value of the function associated with the button.
There is a \verb+toText+ function that takes that value and renders it
for the text box.
Some care to deal with multiple values (which might not be character
strings will be needed).
Also, I believe that if the return type should not be a character
string then editing of the box manually should be prevented, here we
could just render the text.

Each \verb+pWidget+ has the following slots:
\begin{itemize}
\item Name: the print name for the item
\item Value: a value associated with this item
\item toText: a function that takes the value and turns it into a text
  string suitable for rendering in the text box.
\item canEdit: a boolean, can the user edit this box directly or only
  make changes via the button
\item buttonFun: a function associated with the button, the return
  value is put into Value
\item buttonText: the text to appear in the button
\item fromText: a function that takes the text from the text box and
  turns it into a value for the Value slot. If the user is allowed to
  type things in then this will be needed.
\end{itemize}

We will need a boolean vector for the set of pWidgets to monitor
changes.
The return value will be a list with components that include
\begin{itemize}
\item wList: the returned input list with values changed.
\item exit: a character string indicating which button was pushed,
  maybe even error?
\end{itemize}

When a button is clicked and a return value retrieved it is put into
the Value slot and toText is run on it to ensure the text box has up
to date data.

\end{document}
